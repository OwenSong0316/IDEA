package PPACO;

import basePSO.Util;
import java.sql.Time;
import java.util.HashSet;

public class Main {

    public static void main(String[] args) {

//测试样例5：
        double t = Math.sqrt(2) / 2;
        double[][] data = {
                {0,2, 1,2, 1,3, 0,3},
                {4,2-t, 5+t,3, 3,5+t, 2-t,4, 2,4-t, 3,5-t, 5-t,3, 4-t,2},
                {7,1, 8,1, 8,2, 7,2},
                {11,1, 12,1, 12,3, 11,3},
                {10,4, 11,4, 11,5, 10,5},
                {8,3, 9,3, 9,4, 8,4},
                {6,4, 7,4, 7,5, 6,5},
                {3,7, 6,7, 6,8, 5,8, 5,9, 4,9, 4,8, 3,8},
                {7,6, 8,6, 8,8, 7,8},
                {9,7, 10,7, 10,8, 9,8}};
        Obstacle[] obstacles = new Obstacle[data.length];
        for (int i = 0; i < obstacles.length; i++) {
            obstacles[i] = new Obstacle(data[i]);
        }
        Point startPoint = new Point(1, 1);
        Point endPoint = new Point(11, 9);
//测试样例6：
//        double[][] data = {{1,3, 5,3, 5,7, 1,7},
//                        {6,3, 10,3, 10,7, 6,7}};
//        Obstacle[] obstacles = new Obstacle[data.length];
//        for (int i = 0; i < obstacles.length; i++) {
//            obstacles[i] = new Obstacle(data[i]);
//        }
//        Point startPoint = new Point(1, 1);
//        Point endPoint = new Point(11, 9);
//测试样例7：
//        double[][] data = {{3,0, 7,0, 7,5.8, 3,5.8, 3,0},
//                {3,6, 7,6, 7,13, 3,13}};
//        Obstacle[] obstacles = new Obstacle[data.length];
//        for (int i = 0; i < obstacles.length; i++) {
//            obstacles[i] = new Obstacle(data[i]);
//        }
//        Point startPoint = new Point(1, 1);
//        Point endPoint = new Point(11, 9);
//测试样例8：
//        double[][] data = {{1,1, 11,1, 11,11, 1,11,
//                            1,7, 9,7, 9,8, 2,8,
//                            2,10, 10,10, 10,2, 2,2,
//                            2,5, 9,5, 9,6, 1,6}};
//        Obstacle[] obstacles = new Obstacle[data.length];
//        for (int i = 0; i < obstacles.length; i++) {
//            obstacles[i] = new Obstacle(data[i]);
//        }
//        Point startPoint = new Point(0.5, 12.5);
//        Point endPoint = new Point(3, 3);
//测试样例9：
//        double[][] data = {
//                {3,56, 9,56, 9, 68.5, 3,68.5},// 1
//                {12,52, 17,52, 17,63, 12,63},// 2
//                {18.5,53, 28,53, 28,54, 18.5,54},// 3
//                {24.5,57, 38.5,57, 38.5,52, 45,52, 45,60, 38.5,60, 38.5,65, 24.5,65},// 4
//                {30,66, 44,66, 44,68.5, 30,68.5},// 5
//                {60,62, 64,62, 64,70, 60,70},// 6
//                {53,57.5, 68.5,57.5, 68.5,60, 53,60},// 7
//                {80,54, 96,54, 96,70, 80,70},//8
//                {101.5,58, 105,58, 105,67.5, 101.5,67.5},// 9
//                {112,59, 126.5,59, 126.5,67.5, 112,67.5},// 10
//                {105,49, 122,49, 122,56, 105,56},// 11
//                {100,42.5, 114,42.5, 114,47, 100,47},// 12
//                {82,37, 105,37, 105,40, 98,40, 98,51.5, 95,51.5, 95,40, 82,40},// 13
//                {82,43, 85,43, 85,47, 82,47},// 14
//                {67,35, 77,35, 77,50, 67,50},// 15
//                {53.5,45, 56.5,45, 56.5,48, 53.5,48},// 16
//                {45,40, 52.5,40, 52.5,45, 45,45},// 17
//                {25,46, 40,46, 40,50, 25,50},// 18
//                {35,33, 42,33, 42,43, 35,43},// 19
//                {5,40, 20,40, 20,50, 5,50},// 20
//                {9,37, 18,37, 18,38, 9,38},// 21
//                {1.5,26, 14,26, 14,28, 1.5,28},// 22
//                {5,15, 15,15, 15,25, 5,25},// 23
//                {19,16, 22,16, 22,22.5, 19,22.5},// 24
//                {23,22, 25.5,22, 25.5,31.5, 23,31.5},// 25
//                {25,12.5, 31,12.5, 31,17.5, 25,17.5},// 26
//                {34,16, 38,16, 38,24, 34,24},// 27
//                {39,13.5, 44,13.5, 44,15.5, 52.8,15.5, 52.8,17.8, 44,17.8, 44,29, 39,29},// 28
//                {46,18.3, 51,18.3, 51,32.5, 46,32.5},// 29
//                {61,20, 85,20, 85,30, 61,30},// 30
//                {94,24, 100,24, 100,30, 94,30},// 31
//                {103.5,33.5, 114,33.5, 114,36, 103.5,36},// 32
//                {110,28, 125,28, 125,32, 110,32},// 33
//                {105,18, 119,18, 119,20, 105,20},// 34
//                {87.5,10, 100,10, 100,22, 87.5,22},// 35
//                {62,15, 77.5,15, 77.5,17.2, 62,17.2},// 36
//                {2,3, 4,3, 4,6, 2,6},//37
//                {12,7, 16.5,7, 16.5,11.5, 12,11.5},// 38
//                {8,4, 18.5,4, 18.5,6, 8,6},// 39
//                {20,8, 37.5,8, 37.5,10, 20,10},// 40
//                {22.3,1.5, 27,1.5, 27,7, 22.3,7},// 41
//                {39,1.5, 45,1.5, 45,10, 39,10},// 42
//                {55,2.7, 58,2.7, 58,6, 55,6},// 43
//                {65,2.5, 68,2.5, 68,11, 65,11},// 44
//                {75,2.5, 91.5,2.5, 91.5,8, 83,8, 83,14, 75,14},// 45
//                {99,1.8, 109.5,1.8, 109.5,8, 99,8},// 46
//                {120,6, 124.5,6, 124.5,12, 120,12}// 47
//        };
//        Obstacle[] obstacles = new Obstacle[data.length];
//        for (int i = 0; i < obstacles.length; i++) {
//            obstacles[i] = new Obstacle(data[i]);
//        }
//        Point startPoint = new Point(7, 1);
//        Point endPoint = new Point(110, 65);
//测试样例10：
//        double[][] data = {
//                {3,56, 9,56, 9, 68.5, 3,68.5},// 1
//                {12,52, 17,52, 17,63, 12,63},// 2
//                {18.5,53, 28,53, 28,54, 18.5,54},// 3
//                {24.5,57, 38.5,57, 38.5,52, 45,52, 45,60, 38.5,60, 38.5,65, 24.5,65},// 4
//                {30,66, 44,66, 44,68.5, 30,68.5},// 5
//                {60,62, 64,62, 64,70, 60,70},// 6
//                {53,57.5, 68.5,57.5, 68.5,60, 53,60},// 7
//                {80,54, 96,54, 96,70, 80,70},//8
//                {101.5,58, 109.8,58, 109.8,67.5, 101.5,67.5},// 9
//                {110.2,58, 126.5,58, 126.5,67.5, 110.2,67.5},// 10
//                {105,49, 122,49, 122,57.6, 105,57.6},// 11
//                {100,42.5, 114,42.5, 114,47, 100,47},// 12
//                {82,37, 105,37, 105,40, 98,40, 98,51.5, 95,51.5, 95,40, 82,40},// 13
//                {82,43, 85,43, 85,47, 82,47},// 14
//                {67,35, 77,35, 77,50, 67,50},// 15
//                {53.5,45, 56.5,45, 56.5,48, 53.5,48},// 16
//                {45,40, 52.5,40, 52.5,45, 40,45},// 17
//                {25,46, 40,46, 40,50, 25,50},// 18
//                {35,33, 42,33, 42,43, 35,43},// 19
//                {5,40, 20,40, 20,50, 5,50},// 20
//                {9,47, 18,47, 18,48, 9,48},// 21
//                {1.5,26, 14,26, 14,28, 1.5,28},// 22
//                {5,15, 15,15, 15,25, 5,25},// 23
//                {19,16, 22,16, 22,22.5, 19,22.5},// 24
//                {23,22, 25.5,22, 25.5,31.5, 23,31.5},// 25
//                {25,12.5, 31,12.5, 31,17.5, 25,12.5},// 26
//                {34,16, 38,16, 38,24, 34,24},// 27
//                {39,13.5, 44,13.5, 44,15.5, 52.8,15.5, 52.8,17.8, 44,17.8, 44,29, 39,29},// 28
//                {46,18.3, 51,18.3, 51,32.5, 46,32.5},// 29
//                {61,20, 85,20, 85,30, 61,30},// 30
//                {94,24, 100,24, 100,30, 94,30},// 31
//                {103.5,33.5, 114,33.5, 114,36, 103.5,36},// 32
//                {110,28, 125,28, 125,32, 110,32},// 33
//                {105,18, 119,18, 119,20, 105,20},// 34
//                {87.5,10, 100,10, 100,22, 87.5,22},// 35
//                {62,15, 77.5,15, 77.5,17.2, 62,17.2},// 36
//                {2,3, 4,3, 4,6, 2,6},//37
//                {12,7, 16.5,7, 16.5,11.5, 12,11.5},// 38
//                {8,4, 18.5,4, 18.5,6, 8,6},// 39
//                {20,8, 37.5,8, 37.5,10, 20,10},// 40
//                {22.3,1.5, 27,1.5, 27,7, 22.3,7},// 41
//                {39,1.5, 45,1.5, 45,10, 39,10},// 42
//                {55,2.7, 58,2.7, 58,6, 55,6},// 43
//                {65,2.5, 68,2.5, 68,11, 65,11},// 44
//                {75,2.5, 91.5,2.5, 91.5,8, 83,8, 83,14, 75,14},// 45
//                {99,1.8, 109.5,1.8, 109.5,8, 99,8},// 46
//                {120,6, 124.5,6, 124.5,12, 120,12}// 47
//        };
//        Obstacle[] obstacles = new Obstacle[data.length];
//        for (int i = 0; i < obstacles.length; i++) {
//            obstacles[i] = new Obstacle(data[i]);
//        }
//        Point startPoint = new Point(7, 1);
//        Point endPoint = new Point(110, 65);
//测试样例11：
//        double[][] data = {
//                {3,56, 9,56, 9,68.5, 3,68.5},// 1
//                {12,52, 17,52, 17,63, 12,63},// 2
//                {18.5,53, 28,53, 28,54, 18.5,54},// 3
//                {24.5,57, 38.5,57, 38.5,52, 45,52, 45,60, 38.5,60, 38.5,65, 24.5,65},// 4
//                {30,66, 44,66, 44,68.5, 30,68.5},// 5
//                {60,62, 64,62, 64,70, 60,70},// 6
//                {53,57.5, 68.5,57.5, 68.5,60, 53,60},// 7
//                {80,54, 96,54, 96,70, 80,70},//8
//                {105,54, 105,60, 112,60, 112,58, 107,58, 107,56, 114,56,
//                        114,66, 107,66, 107,63, 112,63, 112,61, 105,61, 105,68,
//                        116,68, 116,54},// 9
//                {118,59, 126.5,59, 126.5,67.5, 118,67.5},// 10
//                {105,49, 122,49, 122,52, 105,52},// 11
//                {100,42.5, 114,42.5, 114,47, 100,47},// 12
//                {82,37, 105,37, 105,40, 98,40, 98,51.5, 95,51.5, 95,40, 82,40},// 13
//                {82,43, 85,43, 85,47, 82,47},// 14
//                {67,35, 77,35, 77,50, 67,50},// 15
//                {53.5,45, 56.5,45, 56.5,48, 53.5,48},// 16
//                {45,40, 52.5,40, 52.5,45, 45,45},// 17
//                {25,46, 40,46, 40,50, 25,50},// 18
//                {35,33, 42,33, 42,43, 35,43},// 19
//                {5,40, 20,40, 20,50, 5,50},// 20
//                {9,37, 18,37, 18,38, 9,38},// 21
//                {1.5,26, 14,26, 14,28, 1.5,28},// 22
//                {5,15, 15,15, 15,25, 5,25},// 23
//                {19,16, 22,16, 22,22.5, 19,22.5},// 24
//                {23,22, 25.5,22, 25.5,31.5, 23,31.5},// 25
//                {25,12.5, 31,12.5, 31,17.5, 25,17.5},// 26
//                {34,16, 38,16, 38,24, 34,24},// 27
//                {39,13.5, 44,13.5, 44,15.5, 52.8,15.5, 52.8,17.8, 44,17.8, 44,29, 39,29},// 28
//                {46,18.3, 51,18.3, 51,32.5, 46,32.5},// 29
//                {61,20, 85,20, 85,30, 61,30},// 30
//                {94,24, 100,24, 100,30, 94,30},// 31
//                {103.5,33.5, 114,33.5, 114,36, 103.5,36},// 32
//                {110,28, 125,28, 125,32, 110,32},// 33
//                {105,18, 119,18, 119,20, 105,20},// 34
//                {87.5,10, 100,10, 100,22, 87.5,22},// 35
//                {62,15, 77.5,15, 77.5,17.2, 62,17.2},// 36
//                {2,3, 4,3, 4,6, 2,6},//37
//                {12,7, 16.5,7, 16.5,11.5, 12,11.5},// 38
//                {8,4, 18.5,4, 18.5,6, 8,6},// 39
//                {20,8, 37.5,8, 37.5,10, 20,10},// 40
//                {22.3,1.5, 27,1.5, 27,7, 22.3,7},// 41
//                {39,1.5, 45,1.5, 45,10, 39,10},// 42
//                {55,2.7, 58,2.7, 58,6, 55,6},// 43
//                {65,2.5, 68,2.5, 68,11, 65,11},// 44
//                {75,2.5, 91.5,2.5, 91.5,8, 83,8, 83,14, 75,14},// 45
//                {99,1.8, 109.5,1.8, 109.5,8, 99,8},// 46
//                {120,6, 124.5,6, 124.5,12, 120,12}// 47
//        };
//        Obstacle[] obstacles = new Obstacle[data.length];
//        for (int i = 0; i < obstacles.length; i++) {
//            obstacles[i] = new Obstacle(data[i]);
//        }
//        Point startPoint = new Point(7, 1);
//        Point endPoint = new Point(110, 65);


        //构建网络，找到可行点的过程
        Network network = new Network(obstacles, startPoint, endPoint);

//        System.out.println(network);

//        System.out.print("obs_list = [");
//        for (Obstacle obstacle : obstacles) {
//            System.out.print(obstacle);
//            System.out.print(',');
//        }
//        System.out.println(']');


//-----------------------------------迪杰斯特拉找最优路径----------------------------------------------------
        Dijkstra dijkstra = new Dijkstra(network); //根据可行点寻找最优路径；
        dijkstra.runDijkstra();  //打印可行点
//----------------------------------蚁群算法找最优路径-------------------------------------------------------
//        ACO best = new ACO(network);
//        best.runACO();
//        double avg, min, max;
//        avg = min = max = best.bestFit;
//        for (int i = 1; i < 50; i++) {
//            ACO aco = new ACO(network);
//            aco.runACO();
//            avg += aco.bestFit;
//            max = Math.max(max, aco.bestFit);
//            if (aco.bestFit < min) {
//                best = aco;
//                min = aco.bestFit;
//            }
//        }
//        StringBuilder sbx = new StringBuilder();
//        StringBuilder sby = new StringBuilder();
//        Point point;
//        for (Integer curr : best.bestPath) {
//            point = best.optionalPoints[curr];
//            sbx.append(point.x);
//            sbx.append(',');
//            sby.append(point.y);
//            sby.append(',');
//        }
//        System.out.println("path2 = [[" + sbx + "],[" + sby + "]]");
//        System.out.println(avg / 50 + " " + min + " " + max);

//        double startTime, endTime, maxTime, minTime, avgTime, currTime;
//        double[] times = new double[50];
//
//        startTime = System.nanoTime();
//
//        Network network = new Network(obstacles, startPoint, endPoint);
//
////        ACO aco = new ACO(network);
////        aco.runACO();
//
//        Dijkstra dijkstra = new Dijkstra(network);
//        dijkstra.runDijkstra();
//
//        endTime = System.nanoTime();
//        avgTime = minTime = maxTime = times[0] = (endTime - startTime) / 1000000.0;
//
//        for (int i = 1; i < 50; i++) {
//            startTime = System.nanoTime();
//
//            network = new Network(obstacles, startPoint, endPoint);
////        System.out.println(network);
//
////            aco = new ACO(network);
////            aco.runACO();
//
//            dijkstra = new Dijkstra(network);
//            dijkstra.runDijkstra();
//
//            endTime = System.nanoTime();
//            times[i] = (currTime = (endTime - startTime) / 1000000.0);
//            maxTime = Math.max(maxTime, currTime);
//            minTime = Math.min(minTime, currTime);
//            avgTime += currTime;
//        }
//        double avg = avgTime / 50, sd = 0;
//        for (int i = 0; i < 50; i++) {
//            sd += Math.pow(times[i] - avg, 2);
//        }
//        System.out.println(avg + " " + minTime + " " + maxTime + " " + Math.sqrt(sd / 50));

    }

}